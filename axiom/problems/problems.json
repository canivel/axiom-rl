{
  "problems": [
    {
      "id": "two_sum",
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "function_signature": "def two_sum(nums: List[int], target: int) -> List[int]:",
      "test_cases": [
        {"input": [[2, 7, 11, 15], 9], "expected_output": [0, 1]},
        {"input": [[3, 2, 4], 6], "expected_output": [1, 2]},
        {"input": [[3, 3], 6], "expected_output": [0, 1]},
        {"input": [[1, 5, 3, 7, 2], 9], "expected_output": [3, 4]}
      ],
      "difficulty": "easy",
      "tags": ["array", "hash_table"]
    },
    {
      "id": "fizzbuzz",
      "title": "FizzBuzz",
      "description": "Given an integer n, return a list of strings where for each number from 1 to n: if divisible by 3 and 5, output 'FizzBuzz'; if divisible by 3, output 'Fizz'; if divisible by 5, output 'Buzz'; otherwise output the number as a string.",
      "function_signature": "def fizzbuzz(n: int) -> List[str]:",
      "test_cases": [
        {"input": [3], "expected_output": ["1", "2", "Fizz"]},
        {"input": [5], "expected_output": ["1", "2", "Fizz", "4", "Buzz"]},
        {"input": [15], "expected_output": ["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", "13", "14", "FizzBuzz"]}
      ],
      "difficulty": "easy",
      "tags": ["string", "simulation"]
    },
    {
      "id": "reverse_string",
      "title": "Reverse String",
      "description": "Write a function that reverses a string. The input string is given as a string s. Return the reversed string.",
      "function_signature": "def reverse_string(s: str) -> str:",
      "test_cases": [
        {"input": ["hello"], "expected_output": "olleh"},
        {"input": ["world"], "expected_output": "dlrow"},
        {"input": ["a"], "expected_output": "a"},
        {"input": [""], "expected_output": ""},
        {"input": ["racecar"], "expected_output": "racecar"}
      ],
      "difficulty": "easy",
      "tags": ["string", "two_pointers"]
    },
    {
      "id": "is_palindrome",
      "title": "Valid Palindrome",
      "description": "Given a string s, return true if it is a palindrome considering only alphanumeric characters and ignoring cases. Otherwise return false.",
      "function_signature": "def is_palindrome(s: str) -> bool:",
      "test_cases": [
        {"input": ["A man, a plan, a canal: Panama"], "expected_output": true},
        {"input": ["race a car"], "expected_output": false},
        {"input": [""], "expected_output": true},
        {"input": ["a"], "expected_output": true},
        {"input": ["ab"], "expected_output": false}
      ],
      "difficulty": "easy",
      "tags": ["string", "two_pointers"]
    },
    {
      "id": "max_subarray",
      "title": "Maximum Subarray",
      "description": "Given an integer array nums, find the subarray with the largest sum, and return its sum. A subarray is a contiguous non-empty sequence of elements within an array.",
      "function_signature": "def max_subarray(nums: List[int]) -> int:",
      "test_cases": [
        {"input": [[-2, 1, -3, 4, -1, 2, 1, -5, 4]], "expected_output": 6},
        {"input": [[1]], "expected_output": 1},
        {"input": [[5, 4, -1, 7, 8]], "expected_output": 23},
        {"input": [[-1]], "expected_output": -1},
        {"input": [[-2, -1]], "expected_output": -1}
      ],
      "difficulty": "medium",
      "tags": ["array", "dynamic_programming", "divide_and_conquer"]
    },
    {
      "id": "fibonacci",
      "title": "Fibonacci Number",
      "description": "The Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. Given n, calculate F(n) where F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1.",
      "function_signature": "def fibonacci(n: int) -> int:",
      "test_cases": [
        {"input": [0], "expected_output": 0},
        {"input": [1], "expected_output": 1},
        {"input": [2], "expected_output": 1},
        {"input": [3], "expected_output": 2},
        {"input": [4], "expected_output": 3},
        {"input": [10], "expected_output": 55}
      ],
      "difficulty": "easy",
      "tags": ["math", "dynamic_programming", "recursion"]
    },
    {
      "id": "binary_search",
      "title": "Binary Search",
      "description": "Given a sorted array of distinct integers nums and a target value, return the index if the target is found. If not, return -1.",
      "function_signature": "def binary_search(nums: List[int], target: int) -> int:",
      "test_cases": [
        {"input": [[-1, 0, 3, 5, 9, 12], 9], "expected_output": 4},
        {"input": [[-1, 0, 3, 5, 9, 12], 2], "expected_output": -1},
        {"input": [[5], 5], "expected_output": 0},
        {"input": [[2, 5], 5], "expected_output": 1},
        {"input": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7], "expected_output": 6}
      ],
      "difficulty": "easy",
      "tags": ["array", "binary_search"]
    },
    {
      "id": "valid_parentheses",
      "title": "Valid Parentheses",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.",
      "function_signature": "def valid_parentheses(s: str) -> bool:",
      "test_cases": [
        {"input": ["()"], "expected_output": true},
        {"input": ["()[]{}"], "expected_output": true},
        {"input": ["(]"], "expected_output": false},
        {"input": ["([)]"], "expected_output": false},
        {"input": ["{[]}"], "expected_output": true},
        {"input": [""], "expected_output": true}
      ],
      "difficulty": "easy",
      "tags": ["string", "stack"]
    },
    {
      "id": "merge_sorted_arrays",
      "title": "Merge Sorted Arrays",
      "description": "Given two sorted integer arrays nums1 and nums2, return a new sorted array containing all elements from both arrays.",
      "function_signature": "def merge_sorted_arrays(nums1: List[int], nums2: List[int]) -> List[int]:",
      "test_cases": [
        {"input": [[1, 2, 3], [2, 5, 6]], "expected_output": [1, 2, 2, 3, 5, 6]},
        {"input": [[1], []], "expected_output": [1]},
        {"input": [[], [1]], "expected_output": [1]},
        {"input": [[1, 3, 5], [2, 4, 6]], "expected_output": [1, 2, 3, 4, 5, 6]},
        {"input": [[], []], "expected_output": []}
      ],
      "difficulty": "easy",
      "tags": ["array", "two_pointers", "sorting"]
    },
    {
      "id": "remove_duplicates",
      "title": "Remove Duplicates from Sorted Array",
      "description": "Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length. Return the count of unique elements. The relative order of elements should be kept the same.",
      "function_signature": "def remove_duplicates(nums: List[int]) -> int:",
      "test_cases": [
        {"input": [[1, 1, 2]], "expected_output": 2},
        {"input": [[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]], "expected_output": 5},
        {"input": [[1]], "expected_output": 1},
        {"input": [[1, 2, 3]], "expected_output": 3},
        {"input": [[1, 1, 1, 1]], "expected_output": 1}
      ],
      "difficulty": "easy",
      "tags": ["array", "two_pointers"]
    }
  ]
}
