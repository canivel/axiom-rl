{"problem_id": "fibonacci_train_0", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(9) -> 34\n  fibonacci(8) -> 21\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    fib_0, fib_1 = 0, 1\n    \n    # Compute the nth Fibonacci number iteratively\n    for _ in range(2, n + 1):\n        next_fib = fib_0 + fib_1\n        fib_0, fib_1 = fib_1, next_fib\n    \n    return fib_1", "response": "```python\ndef fibonacci(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    fib_0, fib_1 = 0, 1\n    \n    # Compute the nth Fibonacci number iteratively\n    for _ in range(2, n + 1):\n        next_fib = fib_0 + fib_1\n        fib_0, fib_1 = fib_1, next_fib\n    \n    return fib_1\n```\n\nThis function uses an iterative approach to compute the nth Fibonacci number. It initializes the first two Fibonacci numbers, `fib_0` and `fib_1`, and then iteratively calculates each subsequent Fibonacci number by summing the previous two. The function returns the computed Fibonacci number."}
{"problem_id": "fibonacci_train_1", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(3) -> 2\n  fibonacci(0) -> 0\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n    \n    # Compute the nth Fibonacci number iteratively\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b", "response": "Here's a Python function that computes the nth Fibonacci number:\n\n```python\ndef fibonacci(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n    \n    # Compute the nth Fibonacci number iteratively\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n```\n\n### Explanation:\n- **Base Cases**: The function first checks if `n` is 0 or 1. If so, it returns 0 and 1, respectively.\n- **Initialization**: It initializes two variables, `a` and `b`, to 0 and 1, which represent the first two Fibonacci numbers.\n- **Iterative Calculation**: The function then enters a loop that continues until it reaches the desired position (n). In each iteration, it updates `a` and `b` by swapping their values, effectively generating the next Fibonacci number.\n- **Return Value**: After the loop completes, the function returns the value of `b`, which is the nth Fibonacci number."}
{"problem_id": "fibonacci_train_2", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(0) -> 0\n  fibonacci(1) -> 1\n  fibonacci(9) -> 34\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b", "response": "Here's a Python function to compute the nth Fibonacci number using an iterative approach:\n\n```python\ndef fibonacci(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n```\n\n### Explanation:\n\n1. **Base Cases**: \n   - If `n` is less than 0, the function raises a `ValueError` because negative indices are not allowed in Python.\n   - If `n` is 0 or 1, the function returns 0 and 1, as these are the first two numbers in the Fibonacci sequence.\n\n2. **Iterative Calculation**:\n   - Initialize two variables, `a` and `b`, to 0 and 1, respectively.\n   - Use a loop to calculate the Fibonacci number iteratively from 2 to `n`.\n   - In each iteration, update `a` and `b` to be the sum of the previous two values, effectively building the sequence.\n\n3. **Return the Result**:\n   - After the loop completes, the value of `b` will contain the nth Fibonacci number.\n\nThis function efficiently computes the nth Fibonacci number using an iterative approach, which is both simple and easy to understand."}
{"problem_id": "fibonacci_train_3", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(12) -> 144\n  fibonacci(11) -> 89\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis function calculates the nth Fibonacci number using a simple iterative approach. It initializes the first two Fibonacci numbers, `a` and `b`, to 0 and 1 respectively. Then, it iterates from 2 to `n`, updating the values of `a` and `b` in each iteration to keep track of the last two Fibonacci numbers in the sequence. Finally, it returns the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "remove_duplicates_train_0", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([2, 16, 18, 18, 18, 48]) -> [2, 16, 18, 48]\n  remove_duplicates([2, 2, 2, 3, 6, 6, 6, 14, 14, 14, 15, 15, 15, 28, 28, 28, 33, 33, 38, 39, 39, 45, 45, 45, 49, 49]) -> [2, 3, 6, 14, 15, 28, 33, 38, 39, 45, 49]\n  remove_duplicates([11, 11, 45, 45, 49, 49]) -> [11, 45, 49]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    \"\"\"\n    Remove duplicates from a sorted list and return a new list with duplicates removed.\n\n    Parameters:\n    nums (list): A sorted list of unique integers.\n\n    Returns:\n    list: A new list with duplicates removed, maintaining sorted order.\n    \"\"\"\n    # Initialize an empty list to store unique elements\n    unique_nums = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is not already in the unique_nums list\n        if num not in unique_nums:\n            # If it's not, append it to the unique_nums list\n            unique_nums.append(num)\n    \n    # Return the list of unique elements\n    return unique_nums\n\n# Example usage:\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))         # Output: [1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    \"\"\"\n    Remove duplicates from a sorted list and return a new list with duplicates removed.\n\n    Parameters:\n    nums (list): A sorted list of unique integers.\n\n    Returns:\n    list: A new list with duplicates removed, maintaining sorted order.\n    \"\"\"\n    # Initialize an empty list to store unique elements\n    unique_nums = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is not already in the unique_nums list\n        if num not in unique_nums:\n            # If it's not, append it to the unique_nums list\n            unique_nums.append(num)\n    \n    # Return the list of unique elements\n    return unique_nums\n\n# Example usage:\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))         # Output: [1]\n```\n\nThis solution iterates through the input list, maintaining a list `unique_nums` that contains only the unique elements. It efficiently removes duplicates by checking each element against the `unique_nums` list, ensuring that each element is only added once. The function returns this new list with duplicates removed, preserving the sorted order."}
{"problem_id": "remove_duplicates_train_1", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([3, 15, 19, 43, 43]) -> [3, 15, 19, 43]\n  remove_duplicates([11, 14, 23, 24, 30, 41, 47, 23, 24, 24, 24, 30, 30, 30, 41, 47, 47, 47]) -> [11, 14, 23, 24, 30, 41, 47]\n  remove_duplicates([11, 16, 30, 35, 47, 30, 30, 35, 35, 35, 47, 47, 47]) -> [11, 16, 30, 35, 47]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "from typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    # Initialize a pointer to track the last seen index of a unique element\n    last_seen_index = 0\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is not equal to the last seen element\n        if nums[i] != nums[last_seen_index]:\n            # Move the last seen index forward by one\n            last_seen_index += 1\n            # Append the current element to the result list\n            nums[last_seen_index] = nums[i]\n    \n    # Return the modified list with duplicates removed\n    return nums[:last_seen_index + 1]", "response": "```python\nfrom typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    # Initialize a pointer to track the last seen index of a unique element\n    last_seen_index = 0\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is not equal to the last seen element\n        if nums[i] != nums[last_seen_index]:\n            # Move the last seen index forward by one\n            last_seen_index += 1\n            # Append the current element to the result list\n            nums[last_seen_index] = nums[i]\n    \n    # Return the modified list with duplicates removed\n    return nums[:last_seen_index + 1]\n```\n\nThis function iterates through the given list, comparing each element with the last seen element. If an element is different, it moves the `last_seen_index` forward to the next position and appends the current element to the result list. This ensures that all duplicates are removed while maintaining the original order of the remaining elements."}
{"problem_id": "remove_duplicates_train_4", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 1, 4, 4, 11, 11, 14, 14, 25, 25, 25, 26, 26, 26, 31, 31, 31, 32, 32, 32, 43, 43, 43]) -> [1, 4, 11, 14, 25, 26, 31, 32, 43]\n  remove_duplicates([4, 10, 10, 10, 13, 13, 14, 14, 14, 19, 19, 19, 21, 35, 38, 38, 38, 42, 45]) -> [4, 10, 13, 14, 19, 21, 35, 38, 42, 45]\n  remove_duplicates([5, 5, 16, 39, 39, 39, 44]) -> [5, 16, 39, 44]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "from typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    # Initialize a set to keep track of seen elements\n    seen = set()\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is already in the set\n        if num not in seen:\n            # If not, add it to both the result list and the set\n            result.append(num)\n            seen.add(num)\n    \n    # Return the result list\n    return result", "response": "```python\nfrom typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    # Initialize a set to keep track of seen elements\n    seen = set()\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is already in the set\n        if num not in seen:\n            # If not, add it to both the result list and the set\n            result.append(num)\n            seen.add(num)\n    \n    # Return the result list\n    return result\n```\n\nThis solution works by using a set to keep track of elements that have already been encountered. For each element in the input list, it checks if the element has already been added to the set. If not, it adds the element to both the result list and the set. This ensures that only unique elements are retained in the output list. The time complexity of this solution is O(n), where n is the length of the input list, as we iterate through the list once and perform constant-time operations for each element."}
