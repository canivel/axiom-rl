[
  {
    "id": "parentheses_1",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          "(()"
        ],
        "output": false
      },
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          ")()"
        ],
        "output": false
      }
    ]
  },
  {
    "id": "rpn_3",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "5 4 * 5 - 3 +"
        ],
        "output": 18
      },
      {
        "input": [
          "5 7 -"
        ],
        "output": -2
      },
      {
        "input": [
          "2 3 + 2 +"
        ],
        "output": 7
      },
      {
        "input": [
          "7 9 + 2 * 8 +"
        ],
        "output": 40
      },
      {
        "input": [
          "1 5 * 9 + 6 +"
        ],
        "output": 20
      }
    ]
  },
  {
    "id": "parentheses_4",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "()()()"
        ],
        "output": true
      },
      {
        "input": [
          "][]"
        ],
        "output": false
      },
      {
        "input": [
          "[(])"
        ],
        "output": false
      },
      {
        "input": [
          "[]()()"
        ],
        "output": true
      },
      {
        "input": [
          "(())[]"
        ],
        "output": true
      }
    ]
  },
  {
    "id": "parentheses_5",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "[)"
        ],
        "output": false
      },
      {
        "input": [
          "{}(){}[]"
        ],
        "output": true
      },
      {
        "input": [
          "{[[]]}()"
        ],
        "output": true
      },
      {
        "input": [
          "][]"
        ],
        "output": false
      },
      {
        "input": [
          "[]{}[]{}"
        ],
        "output": true
      }
    ]
  },
  {
    "id": "rpn_2",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "5 6 * 9 +"
        ],
        "output": 39
      },
      {
        "input": [
          "2 3 *"
        ],
        "output": 6
      },
      {
        "input": [
          "2 7 * 7 -"
        ],
        "output": 7
      },
      {
        "input": [
          "3 4 - 3 *"
        ],
        "output": -3
      },
      {
        "input": [
          "5 9 +"
        ],
        "output": 14
      }
    ]
  },
  {
    "id": "rpn_1",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "4 1 +"
        ],
        "output": 5
      },
      {
        "input": [
          "5 1 + 9 -"
        ],
        "output": -3
      },
      {
        "input": [
          "5 9 + 9 +"
        ],
        "output": 23
      },
      {
        "input": [
          "8 9 - 2 *"
        ],
        "output": -2
      },
      {
        "input": [
          "4 7 - 7 +"
        ],
        "output": 4
      }
    ]
  },
  {
    "id": "parentheses_2",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          ")"
        ],
        "output": false
      },
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          "()()"
        ],
        "output": true
      },
      {
        "input": [
          ")"
        ],
        "output": false
      }
    ]
  },
  {
    "id": "rpn_5",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "5 7 - 3 * 2 - 4 -"
        ],
        "output": -12
      },
      {
        "input": [
          "2 6 *"
        ],
        "output": 12
      },
      {
        "input": [
          "3 3 - 9 +"
        ],
        "output": 9
      },
      {
        "input": [
          "8 3 + 8 + 2 *"
        ],
        "output": 38
      },
      {
        "input": [
          "3 3 + 8 -"
        ],
        "output": -2
      }
    ]
  },
  {
    "id": "parentheses_3",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "[()][]"
        ],
        "output": true
      },
      {
        "input": [
          "[[]"
        ],
        "output": false
      },
      {
        "input": [
          "][]"
        ],
        "output": false
      },
      {
        "input": [
          "()()[]"
        ],
        "output": true
      },
      {
        "input": [
          "[][]()"
        ],
        "output": true
      }
    ]
  },
  {
    "id": "rpn_4",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "3 5 * 9 + 7 - 1 +"
        ],
        "output": 18
      },
      {
        "input": [
          "6 6 * 2 * 3 +"
        ],
        "output": 75
      },
      {
        "input": [
          "9 9 - 8 - 6 -"
        ],
        "output": -14
      },
      {
        "input": [
          "6 7 -"
        ],
        "output": -1
      },
      {
        "input": [
          "2 2 - 2 -"
        ],
        "output": -2
      }
    ]
  }
]