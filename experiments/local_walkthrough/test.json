[
  {
    "id": "parentheses_10",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "({)}"
        ],
        "output": false
      },
      {
        "input": [
          "({[]}){}"
        ],
        "output": true
      },
      {
        "input": [
          "{[}]"
        ],
        "output": false
      },
      {
        "input": [
          "{}{}()()"
        ],
        "output": true
      },
      {
        "input": [
          "[][]()()"
        ],
        "output": true
      }
    ]
  },
  {
    "id": "parentheses_11",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "(([]))()"
        ],
        "output": true
      },
      {
        "input": [
          "[][]()()"
        ],
        "output": true
      },
      {
        "input": [
          "[]()[]()"
        ],
        "output": true
      },
      {
        "input": [
          "[[]"
        ],
        "output": false
      },
      {
        "input": [
          "(()"
        ],
        "output": false
      }
    ]
  },
  {
    "id": "rpn_10",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "5 9 * 7 - 1 * 3 +"
        ],
        "output": 41
      },
      {
        "input": [
          "5 5 - 8 +"
        ],
        "output": 8
      },
      {
        "input": [
          "7 6 + 1 - 4 * 5 *"
        ],
        "output": 240
      },
      {
        "input": [
          "4 5 * 7 - 1 +"
        ],
        "output": 14
      },
      {
        "input": [
          "6 6 + 8 +"
        ],
        "output": 20
      }
    ]
  },
  {
    "id": "rpn_11",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "1 8 * 8 + 9 *"
        ],
        "output": 144
      },
      {
        "input": [
          "8 2 * 2 *"
        ],
        "output": 32
      },
      {
        "input": [
          "9 1 - 7 - 5 +"
        ],
        "output": 6
      },
      {
        "input": [
          "6 4 + 7 -"
        ],
        "output": 3
      },
      {
        "input": [
          "6 8 * 4 -"
        ],
        "output": 44
      }
    ]
  },
  {
    "id": "rpn_9",
    "type": "rpn",
    "sig": "def evaluate_rpn(expression: str) -> int:",
    "desc": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.",
    "test_cases": [
      {
        "input": [
          "2 6 - 4 *"
        ],
        "output": -16
      },
      {
        "input": [
          "8 1 - 6 +"
        ],
        "output": 13
      },
      {
        "input": [
          "6 6 * 3 *"
        ],
        "output": 108
      },
      {
        "input": [
          "4 7 * 6 *"
        ],
        "output": 168
      },
      {
        "input": [
          "8 9 - 4 + 3 +"
        ],
        "output": 6
      }
    ]
  },
  {
    "id": "parentheses_9",
    "type": "parentheses",
    "sig": "def is_valid(s: str) -> bool:",
    "desc": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.",
    "test_cases": [
      {
        "input": [
          "([)]"
        ],
        "output": false
      },
      {
        "input": [
          "()()[]"
        ],
        "output": true
      },
      {
        "input": [
          "[[]]()"
        ],
        "output": true
      },
      {
        "input": [
          "()[][]"
        ],
        "output": true
      },
      {
        "input": [
          "[(])"
        ],
        "output": false
      }
    ]
  }
]