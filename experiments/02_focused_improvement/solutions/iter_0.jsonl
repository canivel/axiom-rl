{"problem_id": "remove_duplicates_train_0", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([2, 16, 18, 48, 18, 48]) -> [2, 16, 18, 48]\n  remove_duplicates([2, 3, 6, 14, 15, 28, 33, 38, 39, 45, 49, 15, 15, 28, 28, 28, 33, 33, 38, 39, 39, 45, 45, 45, 49, 49]) -> [2, 3, 6, 14, 15, 28, 33, 38, 39, 45, 49]\n  remove_duplicates([11, 45, 49, 45, 49, 49]) -> [11, 45, 49]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return nums[:i+1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return nums[:i+1]\n```\n\nExplanation:\n- The function first checks if the input list `nums` is empty. If it is, it returns an empty list.\n- It initializes two pointers, `i` and `j`, where `i` points to the current position of the last unique element found, and `j` iterates through the list.\n- Inside the loop, if the elements at indices `i` and `j` are different, it means we have encountered a new unique element. In this case, we increment `i` by one and update the element at index `i` with the value from index `j`.\n- After the loop finishes, we return the sublist of `nums` up to index `i + 1`, which contains all the unique elements in their original order."}
{"problem_id": "remove_duplicates_train_1", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([3, 15, 19, 43, 43]) -> [3, 15, 19, 43]\n  remove_duplicates([11, 14, 23, 24, 30, 41, 47, 23, 24, 24, 24, 30, 30, 30, 41, 47, 47, 47]) -> [11, 14, 23, 24, 30, 41, 47]\n  remove_duplicates([11, 16, 30, 35, 47, 30, 30, 35, 35, 35, 47, 47, 47]) -> [11, 16, 30, 35, 47]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return nums[:i+1]", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    return nums[:i+1]\n```\n\nIn this solution, we iterate through the given list `nums` using two pointers: `i` to keep track of the position where the next unique element should be placed, and `j` to traverse the list. If the current element at `j` is different from the element at `i`, we increment `i` and update the value at `i` to be the current element. This effectively removes duplicates while maintaining the sorted order. The function returns the modified list up to index `i+1`."}
{"problem_id": "remove_duplicates_train_3", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 4, 5, 15, 38, 41, 41, 41, 41]) -> [1, 4, 5, 15, 38, 41]\n  remove_duplicates([9, 14, 18, 32, 35, 43, 18, 18, 18, 32, 32, 35, 43, 43]) -> [9, 14, 18, 32, 35, 43]\n  remove_duplicates([7, 13, 23, 27, 28, 30, 43, 45, 48, 27, 28, 28, 28, 30, 43, 45, 45, 48, 48, 48]) -> [7, 13, 23, 27, 28, 30, 43, 45, 48]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize two pointers: slow to track the unique elements and fast to explore the array\n    slow = 0\n    \n    for fast in range(1, len(nums)):\n        # If the current element is different from the element at the slow pointer,\n        # move the slow pointer forward and update the value at the slow pointer\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    \n    # Return the subarray up to the slow pointer (inclusive)\n    return nums[:slow + 1]", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize two pointers: slow to track the unique elements and fast to explore the array\n    slow = 0\n    \n    for fast in range(1, len(nums)):\n        # If the current element is different from the element at the slow pointer,\n        # move the slow pointer forward and update the value at the slow pointer\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    \n    # Return the subarray up to the slow pointer (inclusive)\n    return nums[:slow + 1]\n```\n\nThis solution uses two pointers: `slow` to keep track of the last unique element found and `fast` to explore the array. When the current element (`nums[fast]`) is different from the element at the `slow` pointer (`nums[slow]`), it means we have found a new unique element, so we increment the `slow` pointer and update the value at the `slow` pointer. This way, we maintain the original order of the elements while removing duplicates. The time complexity is O(n), where n is the length of the input list, and the space complexity is O(1) since we are modifying the input list in place."}
{"problem_id": "remove_duplicates_train_4", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 4, 11, 14, 25, 26, 31, 32, 43, 25, 25, 26, 26, 26, 31, 31, 31, 32, 32, 32, 43, 43, 43]) -> [1, 4, 11, 14, 25, 26, 31, 32, 43]\n  remove_duplicates([4, 10, 13, 14, 19, 21, 35, 38, 42, 45, 19, 19, 21, 35, 38, 38, 38, 42, 45]) -> [4, 10, 13, 14, 19, 21, 35, 38, 42, 45]\n  remove_duplicates([5, 16, 39, 44, 39, 39, 44]) -> [5, 16, 39, 44]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    # Iterate through the list starting from the second element\n    while j < len(nums):\n        # If the current element is not equal to the previous one, move the pointer forward\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n        \n        # Move the second pointer forward\n        j += 1\n    \n    # Return the modified list up to the point where no more duplicates are found\n    return nums[:i+1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    # Iterate through the list starting from the second element\n    while j < len(nums):\n        # If the current element is not equal to the previous one, move the pointer forward\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n        \n        # Move the second pointer forward\n        j += 1\n    \n    # Return the modified list up to the point where no more duplicates are found\n    return nums[:i+1]\n```\n\nThis solution iterates through the given sorted list using two pointers. The first pointer (`i`) keeps track of the last unique element encountered, and the second pointer (`j`) scans through the list to find subsequent duplicates. When it finds a duplicate, it skips that element by moving the `j` pointer forward without changing the `i` pointer. This way, only the first occurrence of each element remains in the list, effectively removing duplicates while preserving the original order. The time complexity of this approach is O(n), where n is the length of the input list, as we traverse the list once. The space complexity is O(1) since we are modifying the input list in place."}
{"problem_id": "remove_duplicates_train_5", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([5, 9, 11, 16, 19, 23, 24, 11, 16, 16, 19, 19, 19, 23, 23, 23, 24, 24, 24]) -> [5, 9, 11, 16, 19, 23, 24]\n  remove_duplicates([20, 36, 43, 36, 43]) -> [20, 36, 43]\n  remove_duplicates([7, 8, 10, 18, 19, 36, 39, 19, 19, 19, 36, 36, 36, 39, 39]) -> [7, 8, 10, 18, 19, 36, 39]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    # Initialize pointers for the current position and the next unique element\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        # If the current element is different from the previous one, move the pointer to the right\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n        \n        # Move the second pointer to the right\n        j += 1\n    \n    # Return the first 'i + 1' elements of the array\n    return nums[:i + 1]", "response": "```python\ndef remove_duplicates(nums):\n    # Initialize pointers for the current position and the next unique element\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        # If the current element is different from the previous one, move the pointer to the right\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n        \n        # Move the second pointer to the right\n        j += 1\n    \n    # Return the first 'i + 1' elements of the array\n    return nums[:i + 1]\n```\n\nThis solution iterates through the given list using two pointers, `i` and `j`. The `i` pointer marks the last unique element found, and the `j` pointer scans through the rest of the list. When it finds an element that is different from the one at `i`, it moves the `i` pointer one step to the right and assigns the value of `j` to the `i` position. This way, all duplicates are moved to the end of the list, and the function returns the subarray up to `i + 1`."}
{"problem_id": "remove_duplicates_train_6", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([3, 3, 7, 7, 7, 9, 9, 14, 14, 14, 16, 16, 16, 20, 23, 24, 48]) -> [3, 7, 9, 14, 16, 20, 23, 24, 48]\n  remove_duplicates([2, 2, 7, 11, 11, 12, 16, 18, 18, 22, 22, 27, 27, 43]) -> [2, 7, 11, 12, 16, 18, 22, 27, 43]\n  remove_duplicates([2, 13, 13, 18, 18, 22, 22, 22, 26, 26, 26, 43, 43]) -> [2, 13, 18, 22, 26, 43]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize the result list to store unique elements\n    result = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is not equal to the last element in the result list\n        if len(result) == 0 or num != result[-1]:\n            # If it's not a duplicate, append it to the result list\n            result.append(num)\n    \n    # Return the resulting list without duplicates\n    return result", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize the result list to store unique elements\n    result = []\n    \n    # Iterate through each element in the input list\n    for num in nums:\n        # Check if the current number is not equal to the last element in the result list\n        if len(result) == 0 or num != result[-1]:\n            # If it's not a duplicate, append it to the result list\n            result.append(num)\n    \n    # Return the resulting list without duplicates\n    return result\n```\n\nExplanation:\nThe function `remove_duplicates` takes a sorted list of integers as input. It initializes an empty list `result` to store the unique elements. The function then iterates through each element in the input list. For each element, it checks if it is different from the last element in the `result` list. If they are different, it appends the element to the `result` list. After iterating through all elements, the function returns the `result` list, which contains only the unique elements from the original list, maintaining their original order. This approach ensures that the time complexity is O(n), where n is the length of the input list, and the space complexity is also O(n) due to the storage of the unique elements."}
{"problem_id": "remove_duplicates_train_7", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([5, 22, 24, 28, 40, 43, 28, 28, 28, 40, 40, 43, 43, 43]) -> [5, 22, 24, 28, 40, 43]\n  remove_duplicates([19, 21, 26, 27, 36, 43, 45, 36, 36, 43, 43, 43, 45, 45, 45]) -> [19, 21, 26, 27, 36, 43, 45]\n  remove_duplicates([20, 26, 36, 37, 40, 37, 40, 40]) -> [20, 26, 36, 37, 40]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize pointers to track the current position and the last unique element's index\n    i = 0\n    j = 0\n    \n    # Iterate through the list starting from the second element\n    while j < len(nums):\n        # If the current element is not equal to the previous one, update the list and move both pointers\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n        # Move the pointer j to the next element\n        j += 1\n    \n    # Return the list up to the point where no more duplicates are found\n    return nums[:i+1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize pointers to track the current position and the last unique element's index\n    i = 0\n    j = 0\n    \n    # Iterate through the list starting from the second element\n    while j < len(nums):\n        # If the current element is not equal to the previous one, update the list and move both pointers\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n        # Move the pointer j to the next element\n        j += 1\n    \n    # Return the list up to the point where no more duplicates are found\n    return nums[:i+1]\n```\n\nIn this solution, we use two pointers, `i` and `j`, to traverse the list. The pointer `i` keeps track of the position where the next unique element should be placed, and the pointer `j` iterates through the list. When we find an element that is different from the element at `i`, we copy it to `nums[i]` and increment `i`. This way, all duplicates are moved to the end of the list while keeping the list sorted. Finally, we return the first part of the list up to `i+1`, which contains only unique elements."}
{"problem_id": "remove_duplicates_train_8", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([16, 31, 40]) -> [16, 31, 40]\n  remove_duplicates([16, 25, 26, 32, 45, 46]) -> [16, 25, 26, 32, 45, 46]\n  remove_duplicates([4, 12, 30, 34, 36, 45]) -> [4, 12, 30, 34, 36, 45]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    i = 0\n    while i < len(nums):\n        if i > 0 and nums[i] == nums[i - 1]:\n            del nums[i]\n        else:\n            i += 1\n    \n    return nums", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    i = 0\n    while i < len(nums):\n        if i > 0 and nums[i] == nums[i - 1]:\n            del nums[i]\n        else:\n            i += 1\n    \n    return nums\n```\n\nExplanation:\n1. Check if the input list `nums` is empty. If it is, return an empty list.\n2. Initialize a pointer `i` to 0.\n3. Iterate through the list using the pointer `i`.\n4. If the current element at index `i` is equal to the element at index `i - 1`, delete the current element from the list.\n5. Otherwise, increment the pointer `i`.\n6. Continue this process until all elements have been processed.\n7. Return the modified list without duplicates."}
{"problem_id": "remove_duplicates_train_9", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([10, 15, 25, 25, 45, 45, 46, 46]) -> [10, 15, 25, 45, 46]\n  remove_duplicates([2, 4, 4, 14, 14, 25, 25, 27, 27, 30, 30, 30, 31, 31, 31, 37, 37, 37, 38, 38, 38, 44, 44, 44, 48]) -> [2, 4, 14, 25, 27, 30, 31, 37, 38, 44, 48]\n  remove_duplicates([2, 11, 11, 11, 15, 15, 15, 18, 22, 22, 25, 25, 25, 26, 26, 26, 28, 28, 28, 30, 32]) -> [2, 11, 15, 18, 22, 25, 26, 28, 30, 32]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for num in nums[1:]:\n        if num != result[-1]:\n            result.append(num)\n    \n    return result", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for num in nums[1:]:\n        if num != result[-1]:\n            result.append(num)\n    \n    return result\n```\n\nThis solution iterates through the given list of numbers, keeping track of the last unique number encountered. It appends each new unique number to the result list. This approach ensures that the resulting list maintains the original order of elements while removing duplicates."}
{"problem_id": "remove_duplicates_train_10", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([8, 11, 20, 24, 39, 47, 48, 39, 39, 39, 47, 47, 47, 48, 48]) -> [8, 11, 20, 24, 39, 47, 48]\n  remove_duplicates([5, 7, 13, 16, 20, 38, 41, 45, 46, 16, 20, 38, 38, 41, 41, 41, 45, 45, 46, 46, 46]) -> [5, 7, 13, 16, 20, 38, 41, 45, 46]\n  remove_duplicates([1, 5, 7, 22, 27, 32, 33, 42, 22, 27, 27, 27, 32, 33, 33, 42]) -> [1, 5, 7, 22, 27, 32, 33, 42]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize pointers for the start and end of the result list\n    start = 0\n    end = 0\n    \n    # Iterate through the input list starting from the second element\n    while end < len(nums):\n        # If the current element is different from the previous one, add it to the result list\n        if nums[end] != nums[end - 1]:\n            nums[start] = nums[end]\n            start += 1\n        \n        # Move the end pointer forward\n        end += 1\n    \n    # Return the first 'start' elements of the modified list\n    return nums[:start]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize pointers for the start and end of the result list\n    start = 0\n    end = 0\n    \n    # Iterate through the input list starting from the second element\n    while end < len(nums):\n        # If the current element is different from the previous one, add it to the result list\n        if nums[end] != nums[end - 1]:\n            nums[start] = nums[end]\n            start += 1\n        \n        # Move the end pointer forward\n        end += 1\n    \n    # Return the first 'start' elements of the modified list\n    return nums[:start]\n```\n\nThis solution iterates through the given list, using two pointers (`start` and `end`) to keep track of the positions where unique elements should be placed and where the next non-duplicate element is found, respectively. It ensures that the original list remains unchanged by copying over non-duplicate elements to the beginning of the list. The time complexity of this approach is O(n), where n is the length of the list, making it efficient for large lists."}
{"problem_id": "remove_duplicates_train_11", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([29, 31, 32, 32, 42, 45, 45, 46, 46, 46]) -> [29, 31, 32, 42, 45, 46]\n  remove_duplicates([20, 20, 20, 24, 24, 31, 31, 36, 36, 36, 38, 38, 38, 43, 43]) -> [20, 24, 31, 36, 38, 43]\n  remove_duplicates([8, 8, 13, 15, 15, 15, 17, 17, 17, 18, 18, 18, 20, 30, 45]) -> [8, 13, 15, 17, 18, 20, 30, 45]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize the result list with the first element of the input list\n    result = [nums[0]]\n    \n    # Iterate through the input list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is different from the last element in the result list,\n        # append it to the result list\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    \n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))       # Output: [1]", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize the result list with the first element of the input list\n    result = [nums[0]]\n    \n    # Iterate through the input list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is different from the last element in the result list,\n        # append it to the result list\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    \n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))       # Output: [1]\n```\n\nThis solution iterates through the given sorted list, comparing each element with the last one added to the result list. If they are different, it appends the current element to the result list. This ensures that all duplicates are removed while maintaining the original order of elements. The function handles edge cases such as an empty list by returning an empty list directly."}
{"problem_id": "remove_duplicates_train_12", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([10, 20, 37]) -> [10, 20, 37]\n  remove_duplicates([15, 15, 15, 20, 20, 25, 25, 27, 27, 27, 29, 29, 29, 34, 39, 39, 39, 40, 40, 40, 41, 47, 49, 49, 49]) -> [15, 20, 25, 27, 29, 34, 39, 40, 41, 47, 49]\n  remove_duplicates([6, 6, 6, 11, 12, 16, 17, 17, 43, 43]) -> [6, 11, 12, 16, 17, 43]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))      # Output: [1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))      # Output: [1]\n```\n\nIn this solution, the function `remove_duplicates` takes a sorted list as input and returns a new list with duplicates removed while preserving the original order of elements. The function initializes a result list with the first element of the input list. It then iterates through the rest of the input list, adding each unique element to the result list if it is different from the last added element. This approach ensures that the resulting list maintains the sorted order of the input list."}
{"problem_id": "remove_duplicates_train_14", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 1, 1, 6, 6, 6, 8, 8, 10, 10, 15, 15, 19, 19, 27, 30, 30, 32, 32, 32, 36, 44, 44]) -> [1, 6, 8, 10, 15, 19, 27, 30, 32, 36, 44]\n  remove_duplicates([5, 5, 9, 9, 9, 18, 18, 27, 33, 33, 39, 39, 39]) -> [5, 9, 18, 27, 33, 39]\n  remove_duplicates([10, 10, 29, 29, 32, 32, 35, 35, 35, 38, 38, 38, 43, 43, 49, 49]) -> [10, 29, 32, 35, 38, 43, 49]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            result.append(nums[i])\n    \n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))  # Output: [1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            result.append(nums[i])\n    \n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))  # Output: [1]\n```\n\nExplanation:\nThe function `remove_duplicates` takes a sorted list `nums` as input. It initializes a result list with the first element of the input list. Then, it iterates through the rest of the elements of the input list starting from the second element. For each element, it checks if it is different from the previous element. If they are different, it appends the current element to the result list. Finally, it returns the result list which contains all unique elements from the input list, maintaining their original order."}
{"problem_id": "remove_duplicates_train_15", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 1, 1, 5, 5, 5, 10, 10, 17, 17, 17, 22, 27, 27, 31, 31, 31, 42, 42, 42, 47, 47, 48, 48]) -> [1, 5, 10, 17, 22, 27, 31, 42, 47, 48]\n  remove_duplicates([3, 5, 5, 5, 6, 6, 6, 15, 16, 16, 19, 28, 28, 28, 35, 35, 40, 41]) -> [3, 5, 6, 15, 16, 19, 28, 35, 40, 41]\n  remove_duplicates([4, 4, 10, 10, 10, 16, 16, 16, 19, 23, 24, 28, 34, 34, 34]) -> [4, 10, 16, 19, 23, 24, 28, 34]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))      # Output: [1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        if nums[i] != result[-1]:\n            result.append(nums[i])\n    return result\n\n# Test cases\nprint(remove_duplicates([1, 1, 2, 2, 3]))  # Output: [1, 2, 3]\nprint(remove_duplicates([1, 1, 1]))      # Output: [1]\n```\n\nThis solution iterates through the given list once, comparing each element with the last one added to the result list. If they are different, it adds the current element to the result list. This ensures that all duplicates are removed while preserving the original order of elements. The time complexity is O(n), where n is the length of the list, as each element is processed exactly once."}
{"problem_id": "remove_duplicates_train_17", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([7, 8, 17, 24, 25, 30, 38, 41, 44, 46, 47, 30, 30, 38, 38, 41, 41, 41, 44, 46, 46, 46, 47]) -> [7, 8, 17, 24, 25, 30, 38, 41, 44, 46, 47]\n  remove_duplicates([3, 8, 9, 20, 27, 32, 42, 43, 45, 48, 42, 43, 43, 45, 45, 45, 48, 48, 48]) -> [3, 8, 9, 20, 27, 32, 42, 43, 45, 48]\n  remove_duplicates([7, 10, 18, 27, 32, 38, 40, 42, 45, 47, 49, 40, 42, 42, 45, 47, 47, 47, 49, 49]) -> [7, 10, 18, 27, 32, 38, 40, 42, 45, 47, 49]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    # Initialize the index to keep track of the unique elements\n    i = 0\n    \n    # Iterate through the list starting from the second element\n    for j in range(1, len(nums)):\n        # If the current element is different from the previous one, update the index and add it to the result\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    # Return the sub-list containing unique elements up to the new length\n    return nums[:i+1]", "response": "```python\ndef remove_duplicates(nums):\n    # Initialize the index to keep track of the unique elements\n    i = 0\n    \n    # Iterate through the list starting from the second element\n    for j in range(1, len(nums)):\n        # If the current element is different from the previous one, update the index and add it to the result\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    \n    # Return the sub-list containing unique elements up to the new length\n    return nums[:i+1]\n```\n\nThis solution iterates through the given list once, comparing each element with the previous one to determine if they are duplicates. If they are not duplicates, it updates the index and adds the element to the result list. The final list contains only the unique elements from the original list, maintaining their original order."}
{"problem_id": "remove_duplicates_train_18", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 9, 23, 9, 23, 23]) -> [1, 9, 23]\n  remove_duplicates([4, 12, 17, 12, 17, 17]) -> [4, 12, 17]\n  remove_duplicates([5, 7, 8, 24, 29, 31, 33, 38, 43, 45, 48, 31, 31, 31, 33, 33, 38, 38, 43, 43, 43, 45, 48]) -> [5, 7, 8, 24, 29, 31, 33, 38, 43, 45, 48]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n        j += 1\n    \n    # Return the first 'i + 1' elements\n    return nums[:i + 1]", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i] = nums[j]\n        j += 1\n    \n    # Return the first 'i + 1' elements\n    return nums[:i + 1]\n```\n\nThis solution iterates through the list using two pointers, `i` and `j`. The pointer `i` keeps track of the position where the next unique element should be placed. When a non-duplicate element is found at `nums[j]`, it is moved to `nums[i+1]` and `i` is incremented. This effectively removes all duplicate elements from the list while maintaining the original order."}
{"problem_id": "remove_duplicates_train_19", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([7, 17, 21, 26, 27, 28, 30, 45, 27, 28, 30, 45]) -> [7, 17, 21, 26, 27, 28, 30, 45]\n  remove_duplicates([4, 7, 9, 24, 36, 38, 42, 45, 48, 36, 38, 38, 38, 42, 42, 45, 45, 45, 48]) -> [4, 7, 9, 24, 36, 38, 42, 45, 48]\n  remove_duplicates([7, 14, 20, 23, 33, 37, 39, 33, 37, 37, 39, 39, 39]) -> [7, 14, 20, 23, 33, 37, 39]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize pointers for the start and end of the modified list\n    start = 0\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is different from the previous one,\n        # place it at the next position in the modified list\n        if nums[i] != nums[start]:\n            start += 1\n            nums[start] = nums[i]\n    \n    # Return the first 'start + 1' elements as the result\n    return nums[:start + 1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize pointers for the start and end of the modified list\n    start = 0\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current element is different from the previous one,\n        # place it at the next position in the modified list\n        if nums[i] != nums[start]:\n            start += 1\n            nums[start] = nums[i]\n    \n    # Return the first 'start + 1' elements as the result\n    return nums[:start + 1]\n```\n\nThis solution iterates through the given sorted list, comparing each element to the one before it. When it finds an element that is not equal to the previous one, it places this element at the next position in the modified list, effectively removing duplicates while preserving the original order of elements. The function then returns the first `start + 1` elements of the modified list, which corresponds to the list without duplicates."}
{"problem_id": "remove_duplicates_train_20", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([10, 12, 37, 12, 12, 37]) -> [10, 12, 37]\n  remove_duplicates([2, 6, 34, 41, 48, 41, 41, 48, 48]) -> [2, 6, 34, 41, 48]\n  remove_duplicates([20, 21, 24, 37, 47, 37, 47]) -> [20, 21, 24, 37, 47]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    \"\"\"\n    Given a sorted list, remove duplicates and return the new list.\n    \n    :param nums: List of integers\n    :return: New list with duplicates removed, maintaining sorted order\n    \"\"\"\n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        if nums[i] != nums[j]:\n            # Move the duplicate to the next position\n            nums[i + 1] = nums[j]\n            i += 1\n        j += 1\n    \n    # Return the first 'i + 1' elements as they are unique\n    return nums[:i + 1]", "response": "```python\ndef remove_duplicates(nums):\n    \"\"\"\n    Given a sorted list, remove duplicates and return the new list.\n    \n    :param nums: List of integers\n    :return: New list with duplicates removed, maintaining sorted order\n    \"\"\"\n    # Initialize two pointers\n    i = 0\n    j = 1\n    \n    while j < len(nums):\n        if nums[i] != nums[j]:\n            # Move the duplicate to the next position\n            nums[i + 1] = nums[j]\n            i += 1\n        j += 1\n    \n    # Return the first 'i + 1' elements as they are unique\n    return nums[:i + 1]\n```\n\nThis solution iterates through the given list using two pointers, `i` and `j`. The pointer `i` keeps track of the last unique element found, and the pointer `j` scans through the list. If the current element at `j` is different from the element at `i`, it moves the unique element to the position after `i` and increments `i`. This effectively removes duplicates while maintaining the original order of the list."}
{"problem_id": "remove_duplicates_train_21", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([1, 1, 4, 9, 14, 14, 17, 17, 17, 19, 19, 20, 39, 46, 46]) -> [1, 4, 9, 14, 17, 19, 20, 39, 46]\n  remove_duplicates([2, 2, 3, 5, 5, 15, 15, 15, 23, 23, 26, 26, 26, 28, 28, 33, 33, 33, 36, 36, 36, 43, 43, 46, 46]) -> [2, 3, 5, 15, 23, 26, 28, 33, 36, 43, 46]\n  remove_duplicates([2, 2, 2, 11, 11, 21, 21, 21, 26, 26]) -> [2, 11, 21, 26]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    unique_nums = [nums[0]]\n    for num in nums[1:]:\n        if num != unique_nums[-1]:\n            unique_nums.append(num)\n    return unique_nums", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    unique_nums = [nums[0]]\n    for num in nums[1:]:\n        if num != unique_nums[-1]:\n            unique_nums.append(num)\n    return unique_nums\n```\n\nThis solution iterates through the given list, checking each element against the last added unique element to determine if it should be included in the result. If the current element is different from the last unique element, it is appended to the `unique_nums` list. This ensures that all duplicate elements are removed while preserving the original order of the elements in the list. The function returns the new list containing only unique elements."}
{"problem_id": "remove_duplicates_train_22", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([7, 10, 10, 10, 13, 16, 16, 16, 17]) -> [7, 10, 13, 16, 17]\n  remove_duplicates([30, 30, 30, 32, 32, 37, 37, 37, 41, 41, 41, 49, 49, 49]) -> [30, 32, 37, 41, 49]\n  remove_duplicates([5, 5, 10, 10, 21, 21, 21, 29, 31, 31, 41, 41, 41, 46, 49, 49]) -> [5, 10, 21, 29, 31, 41, 46, 49]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    unique_nums = [nums[0]]\n    for num in nums[1:]:\n        if num != unique_nums[-1]:\n            unique_nums.append(num)\n    \n    return unique_nums", "response": "```python\ndef remove_duplicates(nums):\n    if not nums:\n        return []\n    \n    unique_nums = [nums[0]]\n    for num in nums[1:]:\n        if num != unique_nums[-1]:\n            unique_nums.append(num)\n    \n    return unique_nums\n```\n\nThis solution iterates through the input list `nums` starting from the second element (index 1). It checks each number against the last number added to the `unique_nums` list. If they are different, it appends the number to `unique_nums`. This way, all duplicate numbers are removed while preserving the original order of the elements. The function returns the resulting list without duplicates."}
{"problem_id": "remove_duplicates_train_23", "problem_type": "remove_duplicates", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Remove Duplicates from Sorted List\n\nGiven a sorted list, remove duplicates and return the new list.\n\nThe input list is sorted in ascending order.\nReturn a new list with duplicates removed, maintaining sorted order.\n\nExample:\n- [1, 1, 2, 2, 3] -> [1, 2, 3]\n- [1, 1, 1] -> [1]\n\nYour function must work for any sorted list.\n\n## Function Signature\n```python\ndef remove_duplicates(nums: list) -> list:\n    # Your implementation here\n```\n\n## Examples\n  remove_duplicates([3, 16, 29, 34, 46, 16, 29, 34, 34, 46, 46]) -> [3, 16, 29, 34, 46]\n  remove_duplicates([4, 22, 25, 27, 39, 41, 44, 27, 39, 41, 41, 41, 44, 44, 44]) -> [4, 22, 25, 27, 39, 41, 44]\n  remove_duplicates([6, 10, 17, 19, 22, 38, 39, 43, 47, 22, 22, 38, 38, 38, 39, 39, 39, 43, 43, 47]) -> [6, 10, 17, 19, 22, 38, 39, 43, 47]\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def remove_duplicates(nums: list) -> list:\n    # Initialize pointers for tracking the current position of the last unique element\n    left = 0\n    \n    # Iterate through the list starting from the second element\n    for right in range(1, len(nums)):\n        # If the current element is different from the previous one, move it to the next position of the last unique element\n        if nums[right] != nums[left]:\n            left += 1\n            nums[left] = nums[right]\n    \n    # Return the list up to the index where all duplicates have been removed\n    return nums[:left + 1]", "response": "```python\ndef remove_duplicates(nums: list) -> list:\n    # Initialize pointers for tracking the current position of the last unique element\n    left = 0\n    \n    # Iterate through the list starting from the second element\n    for right in range(1, len(nums)):\n        # If the current element is different from the previous one, move it to the next position of the last unique element\n        if nums[right] != nums[left]:\n            left += 1\n            nums[left] = nums[right]\n    \n    # Return the list up to the index where all duplicates have been removed\n    return nums[:left + 1]\n```\n\nThis solution iterates through the given list while maintaining two pointers: `left` which tracks the position of the last unique element found so far, and `right` which scans through the rest of the list. When it finds an element that is different from the element at `left`, it moves this element to the position just after `left`. This effectively removes all duplicate elements while keeping the list sorted. The function returns the modified list containing only unique elements."}
{"problem_id": "fibonacci_train_1", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(3) -> 2\n  fibonacci(0) -> 0\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis solution uses a loop to iteratively calculate the Fibonacci numbers up to the nth term. It initializes two variables `a` and `b` to store the last two Fibonacci numbers and then iterates from 2 to `n`, updating these variables to keep track of the current and next Fibonacci numbers. Finally, it returns the nth Fibonacci number. This approach ensures that the function can handle large values of `n` efficiently."}
{"problem_id": "fibonacci_train_3", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(12) -> 144\n  fibonacci(11) -> 89\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\n\nThis solution implements the Fibonacci sequence using a loop. It initializes two variables `a` and `b` to store the first two numbers of the sequence, 0 and 1 respectively. The loop then iterates from 2 up to n, updating `a` and `b` at each step to calculate the next number in the sequence. Finally, it returns the value of `b`, which represents the nth Fibonacci number. This approach ensures that the function works efficiently even for large values of n."}
{"problem_id": "fibonacci_train_4", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(7) -> 13\n  fibonacci(0) -> 0\n  fibonacci(13) -> 233\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\nThis solution uses a loop to calculate the Fibonacci numbers iteratively, starting with the base cases `F(0) = 0` and `F(1) = 1`. The loop runs from 2 to `n`, updating `a` and `b` at each step to compute the next Fibonacci number. Finally, it returns the value of `b`, which is the nth Fibonacci number."}
{"problem_id": "fibonacci_train_5", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(2) -> 1\n  fibonacci(7) -> 13\n  fibonacci(6) -> 8\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis solution uses dynamic programming to efficiently compute the nth Fibonacci number by storing intermediate results in variables `a` and `b`. The loop iterates from 2 to `n`, updating `a` and `b` at each step to calculate the next Fibonacci number. This approach avoids redundant calculations, making it suitable for large values of `n`."}
{"problem_id": "fibonacci_train_7", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(4) -> 3\n  fibonacci(2) -> 1\n  fibonacci(9) -> 34\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\n\nThe `fibonacci` function computes the nth Fibonacci number using an iterative approach. It initializes two variables, `a` and `b`, to 0 and 1 respectively. Then, it iterates from 2 to n (inclusive), updating the values of `a` and `b` at each step to calculate the next Fibonacci number. Finally, it returns the value of `b`, which represents the nth Fibonacci number. This approach ensures that the function works efficiently for large values of n."}
{"problem_id": "fibonacci_train_8", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(7) -> 13\n  fibonacci(1) -> 1\n  fibonacci(2) -> 1\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis solution implements the Fibonacci sequence using an iterative approach. The function initializes two variables `a` and `b` to represent the first two Fibonacci numbers (0 and 1). It then iterates from the third number up to the nth number, updating `a` and `b` at each step to calculate the next Fibonacci number by summing the previous two numbers. Finally, it returns the nth Fibonacci number. This method is efficient and works well for large values of n."}
{"problem_id": "fibonacci_train_10", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(6) -> 8\n  fibonacci(3) -> 2\n  fibonacci(8) -> 21\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\n\nThis function uses an iterative approach to calculate the nth Fibonacci number. It initializes two variables `a` and `b` to 0 and 1 respectively, which are the first two numbers of the Fibonacci sequence. Then, it iterates from 2 to n, updating `a` and `b` to be the next two numbers in the sequence by adding them together. Finally, it returns the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_11", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(0) -> 0\n  fibonacci(12) -> 144\n  fibonacci(2) -> 1\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nIn this solution, we implement the Fibonacci function using a loop to calculate the value of the nth Fibonacci number iteratively. The function first handles the base cases where n is 0 or 1 by returning the corresponding Fibonacci number directly. For larger values of n, it initializes two variables `a` and `b` to store the last two Fibonacci numbers and then iterates from 2 up to n, updating these variables to keep track of the current and next Fibonacci numbers. Finally, it returns the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_14", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(2) -> 1\n  fibonacci(1) -> 1\n  fibonacci(6) -> 8\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThe provided function `fibonacci` computes the nth Fibonacci number using a loop. It initializes two variables `a` and `b` to 0 and 1 respectively, which represent the first two numbers in the Fibonacci sequence. The loop then iterates from 2 up to n, updating `a` and `b` at each step to calculate the next Fibonacci number by summing the previous two numbers. Finally, it returns the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_15", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(4) -> 3\n  fibonacci(2) -> 1\n  fibonacci(0) -> 0\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\nIn this solution, we use a loop to iteratively calculate the Fibonacci numbers up to the nth term. We initialize two variables `a` and `b` with the first two Fibonacci numbers, 0 and 1 respectively. Then, in each iteration of the loop, we update `a` and `b` to be `b` and the sum of `a` and `b`, respectively, effectively building up the Fibonacci sequence. Finally, we return the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_16", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(6) -> 8\n  fibonacci(8) -> 21\n  fibonacci(0) -> 0\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\n\nIn this solution, we use a loop to iteratively calculate the Fibonacci numbers up to the nth term. The initial two terms of the sequence (F(0) and F(1)) are hardcoded as 0 and 1, respectively. For each subsequent term, we update the values of `a` and `b` such that `b` becomes the sum of the previous two terms (`a + b`). This process continues until we reach the nth term. Finally, we return the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_17", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(4) -> 3\n  fibonacci(13) -> 233\n  fibonacci(0) -> 0\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis function uses a loop to calculate the nth Fibonacci number iteratively. It initializes two variables `a` and `b` to 0 and 1 respectively, representing the first two numbers of the Fibonacci sequence. The loop runs from 2 to n (inclusive), updating `a` and `b` at each iteration to compute the next Fibonacci number. Finally, it returns the computed Fibonacci number."}
{"problem_id": "fibonacci_train_19", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(0) -> 0\n  fibonacci(10) -> 55\n  fibonacci(12) -> 144\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```\n\nThis solution uses a simple iterative approach to calculate the Fibonacci number by maintaining two variables `a` and `b`, updating them at each step until reaching the desired index `n`. The time complexity of this algorithm is O(n), making it efficient for large values of `n`."}
{"problem_id": "fibonacci_train_20", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(14) -> 377\n  fibonacci(11) -> 89\n  fibonacci(3) -> 2\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\nIn this solution, we define a function `fibonacci` that takes an integer `n` as input and returns the nth Fibonacci number using an iterative approach. The function initializes two variables `a` and `b` to 0 and 1 respectively, which represent the first two numbers of the Fibonacci sequence. It then iterates from 2 to `n`, updating `a` and `b` at each step to calculate the next Fibonacci number. Finally, it returns the value of `b`, which represents the nth Fibonacci number. This approach ensures that the function works efficiently even for large values of `n`."}
{"problem_id": "fibonacci_train_21", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(0) -> 0\n  fibonacci(2) -> 1\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThe `fibonacci` function calculates the nth Fibonacci number using an iterative approach. It initializes two variables `a` and `b` to 0 and 1 respectively, which represent the first two numbers of the Fibonacci sequence. Then, it iterates from 2 to n (inclusive), updating `a` and `b` at each step to compute the next Fibonacci number. Finally, it returns the value of `b`, which represents the nth Fibonacci number. This method ensures that the function works efficiently for large values of n by avoiding the exponential time complexity of a naive recursive solution."}
{"problem_id": "fibonacci_train_22", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(0) -> 0\n  fibonacci(7) -> 13\n  fibonacci(5) -> 5\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\n\nThis function uses a loop to calculate the Fibonacci number iteratively. It initializes two variables `a` and `b` to 0 and 1 respectively, which represent the first two numbers in the Fibonacci sequence. Then it enters a loop that continues until it reaches the nth number. In each iteration, it updates `a` and `b` to be the current values of `b` and `a + b`, respectively. Finally, it returns the value of `b`, which represents the nth Fibonacci number."}
{"problem_id": "fibonacci_train_23", "problem_type": "fibonacci", "prompt": "Solve the following problem by implementing the function.\n\n## Problem: Fibonacci Number\n\nImplement a function to compute the nth Fibonacci number.\n\nThe Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\n- F(0) = 0\n- F(1) = 1\n- F(n) = F(n-1) + F(n-2) for n > 1\n\nYour function must work for any non-negative integer n.\n\n## Function Signature\n```python\ndef fibonacci(n: int) -> int:\n    # Your implementation here\n```\n\n## Examples\n  fibonacci(1) -> 1\n  fibonacci(0) -> 0\n  fibonacci(5) -> 5\n\nWrite ONLY the complete function implementation that works for ALL inputs, not just the examples.", "code": "def fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "response": "```python\ndef fibonacci(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n```\nThis solution uses a loop to iteratively calculate the Fibonacci numbers until it reaches the desired index `n`. The first two Fibonacci numbers (F(0) and F(1)) are initialized to 0 and 1 respectively, and then the rest of the numbers are calculated by summing up the previous two numbers in the sequence. This approach ensures that the function works efficiently even for large values of `n`."}
