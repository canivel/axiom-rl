{"problem_id": "rpn_1", "problem_type": "rpn", "title": "RPN Expression Evaluator", "description": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.", "function_signature": "def evaluate_rpn(expression: str) -> int:", "solution_code": "from typing import List\n\ndef evaluate_rpn(expression: str) -> int:\n    stack: List[int] = []\n    \n    def apply_operator(operand1, operand2, operator):\n        if operator == '+':\n            return operand1 + operand2\n        elif operator == '-':\n            return operand1 - operand2\n        elif operator == '*':\n            return operand1 * operand2\n    \n    tokens = expression.split()\n    \n    for token in tokens:\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            second_operand = stack.pop()\n            first_operand = stack.pop()\n            stack.append(apply_operator(first_operand, second_operand, token))\n    \n    return stack[0]", "test_cases_passed": 3}
{"problem_id": "rpn_2", "problem_type": "rpn", "title": "RPN Expression Evaluator", "description": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.", "function_signature": "def evaluate_rpn(expression: str) -> int:", "solution_code": "def evaluate_rpn(expression: str) -> int:\n    stack = []\n    operations = {'+': lambda x, y: x + y, '-': lambda x, y: x - y, '*': lambda x, y: x * y}\n\n    tokens = expression.split()\n\n    for token in tokens:\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            right = stack.pop()\n            left = stack.pop()\n            result = operations[token](left, right)\n            stack.append(result)\n\n    return stack[0]", "test_cases_passed": 3}
{"problem_id": "rpn_3", "problem_type": "rpn", "title": "RPN Expression Evaluator", "description": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.", "function_signature": "def evaluate_rpn(expression: str) -> int:", "solution_code": "def evaluate_rpn(expression: str) -> int:\n    stack = []\n    \n    for token in expression.split():\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            right = stack.pop()\n            left = stack.pop()\n            \n            if token == '+':\n                stack.append(left + right)\n            elif token == '-':\n                stack.append(left - right)\n            elif token == '*':\n                stack.append(left * right)\n    \n    return stack[0]", "test_cases_passed": 3}
{"problem_id": "rpn_5", "problem_type": "rpn", "title": "RPN Expression Evaluator", "description": "Implement a Reverse Polish Notation (RPN) expression evaluator.\n\nIn RPN, operators come AFTER their operands:\n- \"3 4 +\" means 3 + 4 = 7\n- \"3 4 + 2 *\" means (3 + 4) * 2 = 14\n- \"5 1 2 + 4 * + 3 -\" means 5 + ((1 + 2) * 4) - 3 = 14\n\nRules:\n- Tokens are separated by spaces\n- Valid operators: +, -, *\n- All numbers are single-digit positive integers (1-9)\n- Return the final result as an integer\n\nYour function must work for ANY valid RPN expression, not just the examples.", "function_signature": "def evaluate_rpn(expression: str) -> int:", "solution_code": "def evaluate_rpn(expression: str) -> int:\n    stack = []\n    \n    for token in expression.split():\n        if token.isdigit():\n            stack.append(int(token))\n        else:\n            b = stack.pop()\n            a = stack.pop()\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n    \n    return stack[0]", "test_cases_passed": 3}
{"problem_id": "parentheses_1", "problem_type": "parentheses", "title": "Valid Parentheses Checker", "description": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.", "function_signature": "def is_valid(s: str) -> bool:", "solution_code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    \n    return not stack", "test_cases_passed": 3}
{"problem_id": "parentheses_2", "problem_type": "parentheses", "title": "Valid Parentheses Checker", "description": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.", "function_signature": "def is_valid(s: str) -> bool:", "solution_code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char] != stack.pop():\n                return False\n    \n    return len(stack) == 0", "test_cases_passed": 3}
{"problem_id": "parentheses_4", "problem_type": "parentheses", "title": "Valid Parentheses Checker", "description": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.", "function_signature": "def is_valid(s: str) -> bool:", "solution_code": "def is_valid(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '(' or char == '[' or char == '{':\n            stack.append(char)\n        else:\n            if not stack or (stack.pop() != '(' and stack.pop() != '[' and stack.pop() != '{'):\n                return False\n    return len(stack) == 0", "test_cases_passed": 3}
{"problem_id": "parentheses_5", "problem_type": "parentheses", "title": "Valid Parentheses Checker", "description": "Implement a function to check if a string of brackets is valid.\n\nA string is valid if:\n1. Open brackets are closed by the same type of brackets\n2. Open brackets are closed in the correct order\n3. Every close bracket has a corresponding open bracket\n\nValid brackets: (), [], {}\n\nYour function must work for ANY bracket string, not just the examples.", "function_signature": "def is_valid(s: str) -> bool:", "solution_code": "def is_valid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            raise ValueError(\"Invalid character encountered\")\n\n    return len(stack) == 0", "test_cases_passed": 3}
