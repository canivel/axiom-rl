{"problem_type": "n_queens", "problem_id": "n_queens_1", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [1], "expected_output": 1}, {"input_args": [1], "expected_output": 1}, {"input_args": [3], "expected_output": 0}, {"input_args": [2], "expected_output": 0}, {"input_args": [2], "expected_output": 0}], "difficulty": 3, "thinking": "Step 1: Understand the problem - N-Queens asks to count all valid placements of N queens on an NxN chessboard where no two queens attack each other.\n\nStep 2: Key insight - Queens attack on rows, columns, and diagonals. We can place exactly one queen per row, so we iterate row by row.\n\nStep 3: Use backtracking with constraint tracking:\n- Track occupied columns with a set\n- Track occupied diagonals (row-col) with a set\n- Track occupied anti-diagonals (row+col) with a set\n\nStep 4: Time complexity O(N!), Space O(N) for the recursion stack and sets.\n\nStep 5: Base case - when row == n, we found a valid placement, count it.", "solution_code": "def n_queens(n: int) -> int:\n    count = 0\n    cols = set()\n    diag1 = set()  # row - col\n    diag2 = set()  # row + col\n\n    def backtrack(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            backtrack(row + 1)\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    backtrack(0)\n    return count", "raw_response": "<think>\nStep 1: Understand the problem - N-Queens asks to count all valid placements of N queens on an NxN chessboard where no two queens attack each other.\n\nStep 2: Key insight - Queens attack on rows, columns, and diagonals. We can place exactly one queen per row, so we iterate row by row.\n\nStep 3: Use backtracking with constraint tracking:\n- Track occupied columns with a set\n- Track occupied diagonals (row-col) with a set\n- Track occupied anti-diagonals (row+col) with a set\n\nStep 4: Time complexity O(N!), Space O(N) for the recursion stack and sets.\n\nStep 5: Base case - when row == n, we found a valid placement, count it.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    count = 0\n    cols = set()\n    diag1 = set()  # row - col\n    diag2 = set()  # row + col\n\n    def backtrack(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            backtrack(row + 1)\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    backtrack(0)\n    return count\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_2", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [2], "expected_output": 0}, {"input_args": [1], "expected_output": 1}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [1], "expected_output": 1}], "difficulty": 3, "thinking": "Step 1: Understand the problem - N-Queens asks to count all valid placements of N queens on an NxN chessboard where no two queens attack each other.\n\nStep 2: Key insight - Queens attack on rows, columns, and diagonals. We can place exactly one queen per row, so we iterate row by row.\n\nStep 3: Use backtracking with constraint tracking:\n- Track occupied columns with a set\n- Track occupied diagonals (row-col) with a set\n- Track occupied anti-diagonals (row+col) with a set\n\nStep 4: Time complexity O(N!), Space O(N) for the recursion stack and sets.\n\nStep 5: Base case - when row == n, we found a valid placement, count it.", "solution_code": "def n_queens(n: int) -> int:\n    count = 0\n    cols = set()\n    diag1 = set()  # row - col\n    diag2 = set()  # row + col\n\n    def backtrack(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            backtrack(row + 1)\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    backtrack(0)\n    return count", "raw_response": "<think>\nStep 1: Understand the problem - N-Queens asks to count all valid placements of N queens on an NxN chessboard where no two queens attack each other.\n\nStep 2: Key insight - Queens attack on rows, columns, and diagonals. We can place exactly one queen per row, so we iterate row by row.\n\nStep 3: Use backtracking with constraint tracking:\n- Track occupied columns with a set\n- Track occupied diagonals (row-col) with a set\n- Track occupied anti-diagonals (row+col) with a set\n\nStep 4: Time complexity O(N!), Space O(N) for the recursion stack and sets.\n\nStep 5: Base case - when row == n, we found a valid placement, count it.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    count = 0\n    cols = set()\n    diag1 = set()  # row - col\n    diag2 = set()  # row + col\n\n    def backtrack(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                continue\n            cols.add(col)\n            diag1.add(row - col)\n            diag2.add(row + col)\n            backtrack(row + 1)\n            cols.remove(col)\n            diag1.remove(row - col)\n            diag2.remove(row + col)\n\n    backtrack(0)\n    return count\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_3", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [1], "expected_output": 1}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [4], "expected_output": 2}, {"input_args": [1], "expected_output": 1}], "difficulty": 4, "thinking": "Step 1: N-Queens problem - count valid queen placements where no two queens share row, column, or diagonal.\n\nStep 2: Approach - place one queen per row using backtracking. Track constraints with boolean arrays.\n\nStep 3: For each row, try each column. Check if column and both diagonals are free.\n\nStep 4: Diagonal constraint: queens on same diagonal have same (row-col), same anti-diagonal have same (row+col).\n\nStep 5: Use arrays of size n for columns, 2n-1 for diagonals.", "solution_code": "def n_queens(n: int) -> int:\n    result = 0\n    col_used = [False] * n\n    diag_used = [False] * (2 * n - 1)\n    anti_diag_used = [False] * (2 * n - 1)\n\n    def solve(row):\n        nonlocal result\n        if row == n:\n            result += 1\n            return\n        for col in range(n):\n            d1 = row - col + n - 1\n            d2 = row + col\n            if col_used[col] or diag_used[d1] or anti_diag_used[d2]:\n                continue\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = True\n            solve(row + 1)\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = False\n\n    solve(0)\n    return result", "raw_response": "<think>\nStep 1: N-Queens problem - count valid queen placements where no two queens share row, column, or diagonal.\n\nStep 2: Approach - place one queen per row using backtracking. Track constraints with boolean arrays.\n\nStep 3: For each row, try each column. Check if column and both diagonals are free.\n\nStep 4: Diagonal constraint: queens on same diagonal have same (row-col), same anti-diagonal have same (row+col).\n\nStep 5: Use arrays of size n for columns, 2n-1 for diagonals.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    result = 0\n    col_used = [False] * n\n    diag_used = [False] * (2 * n - 1)\n    anti_diag_used = [False] * (2 * n - 1)\n\n    def solve(row):\n        nonlocal result\n        if row == n:\n            result += 1\n            return\n        for col in range(n):\n            d1 = row - col + n - 1\n            d2 = row + col\n            if col_used[col] or diag_used[d1] or anti_diag_used[d2]:\n                continue\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = True\n            solve(row + 1)\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = False\n\n    solve(0)\n    return result\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_4", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [4], "expected_output": 2}, {"input_args": [6], "expected_output": 4}, {"input_args": [4], "expected_output": 2}, {"input_args": [6], "expected_output": 4}, {"input_args": [5], "expected_output": 10}], "difficulty": 4, "thinking": "Step 1: N-Queens problem - count valid queen placements where no two queens share row, column, or diagonal.\n\nStep 2: Approach - place one queen per row using backtracking. Track constraints with boolean arrays.\n\nStep 3: For each row, try each column. Check if column and both diagonals are free.\n\nStep 4: Diagonal constraint: queens on same diagonal have same (row-col), same anti-diagonal have same (row+col).\n\nStep 5: Use arrays of size n for columns, 2n-1 for diagonals.", "solution_code": "def n_queens(n: int) -> int:\n    result = 0\n    col_used = [False] * n\n    diag_used = [False] * (2 * n - 1)\n    anti_diag_used = [False] * (2 * n - 1)\n\n    def solve(row):\n        nonlocal result\n        if row == n:\n            result += 1\n            return\n        for col in range(n):\n            d1 = row - col + n - 1\n            d2 = row + col\n            if col_used[col] or diag_used[d1] or anti_diag_used[d2]:\n                continue\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = True\n            solve(row + 1)\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = False\n\n    solve(0)\n    return result", "raw_response": "<think>\nStep 1: N-Queens problem - count valid queen placements where no two queens share row, column, or diagonal.\n\nStep 2: Approach - place one queen per row using backtracking. Track constraints with boolean arrays.\n\nStep 3: For each row, try each column. Check if column and both diagonals are free.\n\nStep 4: Diagonal constraint: queens on same diagonal have same (row-col), same anti-diagonal have same (row+col).\n\nStep 5: Use arrays of size n for columns, 2n-1 for diagonals.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    result = 0\n    col_used = [False] * n\n    diag_used = [False] * (2 * n - 1)\n    anti_diag_used = [False] * (2 * n - 1)\n\n    def solve(row):\n        nonlocal result\n        if row == n:\n            result += 1\n            return\n        for col in range(n):\n            d1 = row - col + n - 1\n            d2 = row + col\n            if col_used[col] or diag_used[d1] or anti_diag_used[d2]:\n                continue\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = True\n            solve(row + 1)\n            col_used[col] = diag_used[d1] = anti_diag_used[d2] = False\n\n    solve(0)\n    return result\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_5", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [6], "expected_output": 4}, {"input_args": [5], "expected_output": 10}, {"input_args": [5], "expected_output": 10}], "difficulty": 5, "thinking": "Step 1: The N-Queens counting problem requires finding all ways to place N non-attacking queens.\n\nStep 2: Two queens attack if they share row, column, or diagonal. Row constraint is automatic (one per row).\n\nStep 3: Use backtracking - at each row, try placing queen in each column that doesn't conflict.\n\nStep 4: Check conflicts using: columns set, positive diagonal (r-c), negative diagonal (r+c).\n\nStep 5: When we successfully place queen in last row (row==n), we found one valid configuration.", "solution_code": "def n_queens(n: int) -> int:\n    def is_safe(queens, row, col):\n        for r, c in enumerate(queens):\n            if c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def backtrack(queens):\n        row = len(queens)\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if is_safe(queens, row, col):\n                count += backtrack(queens + [col])\n        return count\n\n    return backtrack([])", "raw_response": "<think>\nStep 1: The N-Queens counting problem requires finding all ways to place N non-attacking queens.\n\nStep 2: Two queens attack if they share row, column, or diagonal. Row constraint is automatic (one per row).\n\nStep 3: Use backtracking - at each row, try placing queen in each column that doesn't conflict.\n\nStep 4: Check conflicts using: columns set, positive diagonal (r-c), negative diagonal (r+c).\n\nStep 5: When we successfully place queen in last row (row==n), we found one valid configuration.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def is_safe(queens, row, col):\n        for r, c in enumerate(queens):\n            if c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def backtrack(queens):\n        row = len(queens)\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if is_safe(queens, row, col):\n                count += backtrack(queens + [col])\n        return count\n\n    return backtrack([])\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_6", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [4], "expected_output": 2}, {"input_args": [4], "expected_output": 2}, {"input_args": [5], "expected_output": 10}, {"input_args": [1], "expected_output": 1}, {"input_args": [1], "expected_output": 1}], "difficulty": 5, "thinking": "Step 1: The N-Queens counting problem requires finding all ways to place N non-attacking queens.\n\nStep 2: Two queens attack if they share row, column, or diagonal. Row constraint is automatic (one per row).\n\nStep 3: Use backtracking - at each row, try placing queen in each column that doesn't conflict.\n\nStep 4: Check conflicts using: columns set, positive diagonal (r-c), negative diagonal (r+c).\n\nStep 5: When we successfully place queen in last row (row==n), we found one valid configuration.", "solution_code": "def n_queens(n: int) -> int:\n    def is_safe(queens, row, col):\n        for r, c in enumerate(queens):\n            if c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def backtrack(queens):\n        row = len(queens)\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if is_safe(queens, row, col):\n                count += backtrack(queens + [col])\n        return count\n\n    return backtrack([])", "raw_response": "<think>\nStep 1: The N-Queens counting problem requires finding all ways to place N non-attacking queens.\n\nStep 2: Two queens attack if they share row, column, or diagonal. Row constraint is automatic (one per row).\n\nStep 3: Use backtracking - at each row, try placing queen in each column that doesn't conflict.\n\nStep 4: Check conflicts using: columns set, positive diagonal (r-c), negative diagonal (r+c).\n\nStep 5: When we successfully place queen in last row (row==n), we found one valid configuration.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def is_safe(queens, row, col):\n        for r, c in enumerate(queens):\n            if c == col or abs(r - row) == abs(c - col):\n                return False\n        return True\n\n    def backtrack(queens):\n        row = len(queens)\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            if is_safe(queens, row, col):\n                count += backtrack(queens + [col])\n        return count\n\n    return backtrack([])\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_7", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [6], "expected_output": 4}, {"input_args": [1], "expected_output": 1}, {"input_args": [5], "expected_output": 10}, {"input_args": [5], "expected_output": 10}, {"input_args": [5], "expected_output": 10}], "difficulty": 6, "thinking": "Step 1: N-Queens - count arrangements of N queens on NxN board with no attacks.\n\nStep 2: Use bit manipulation for efficiency. Each bit represents a column position.\n\nStep 3: Track three constraints as bitmasks: columns, left diagonals, right diagonals.\n\nStep 4: Available positions = ~(cols | diag_left | diag_right) & ((1 << n) - 1)\n\nStep 5: Extract lowest set bit with pos & -pos, iterate through all available positions.", "solution_code": "def n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        count = 0\n        available = ~(cols | d1 | d2) & ((1 << n) - 1)\n        while available:\n            pos = available & -available\n            available -= pos\n            count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1)\n        return count\n\n    return solve(0, 0, 0, 0)", "raw_response": "<think>\nStep 1: N-Queens - count arrangements of N queens on NxN board with no attacks.\n\nStep 2: Use bit manipulation for efficiency. Each bit represents a column position.\n\nStep 3: Track three constraints as bitmasks: columns, left diagonals, right diagonals.\n\nStep 4: Available positions = ~(cols | diag_left | diag_right) & ((1 << n) - 1)\n\nStep 5: Extract lowest set bit with pos & -pos, iterate through all available positions.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        count = 0\n        available = ~(cols | d1 | d2) & ((1 << n) - 1)\n        while available:\n            pos = available & -available\n            available -= pos\n            count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1)\n        return count\n\n    return solve(0, 0, 0, 0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_8", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [1], "expected_output": 1}, {"input_args": [6], "expected_output": 4}, {"input_args": [1], "expected_output": 1}, {"input_args": [6], "expected_output": 4}, {"input_args": [1], "expected_output": 1}], "difficulty": 6, "thinking": "Step 1: N-Queens - count arrangements of N queens on NxN board with no attacks.\n\nStep 2: Use bit manipulation for efficiency. Each bit represents a column position.\n\nStep 3: Track three constraints as bitmasks: columns, left diagonals, right diagonals.\n\nStep 4: Available positions = ~(cols | diag_left | diag_right) & ((1 << n) - 1)\n\nStep 5: Extract lowest set bit with pos & -pos, iterate through all available positions.", "solution_code": "def n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        count = 0\n        available = ~(cols | d1 | d2) & ((1 << n) - 1)\n        while available:\n            pos = available & -available\n            available -= pos\n            count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1)\n        return count\n\n    return solve(0, 0, 0, 0)", "raw_response": "<think>\nStep 1: N-Queens - count arrangements of N queens on NxN board with no attacks.\n\nStep 2: Use bit manipulation for efficiency. Each bit represents a column position.\n\nStep 3: Track three constraints as bitmasks: columns, left diagonals, right diagonals.\n\nStep 4: Available positions = ~(cols | diag_left | diag_right) & ((1 << n) - 1)\n\nStep 5: Extract lowest set bit with pos & -pos, iterate through all available positions.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        count = 0\n        available = ~(cols | d1 | d2) & ((1 << n) - 1)\n        while available:\n            pos = available & -available\n            available -= pos\n            count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1)\n        return count\n\n    return solve(0, 0, 0, 0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.076539"}
{"problem_type": "n_queens", "problem_id": "n_queens_9", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [8], "expected_output": 92}, {"input_args": [6], "expected_output": 4}, {"input_args": [8], "expected_output": 92}, {"input_args": [6], "expected_output": 4}, {"input_args": [8], "expected_output": 92}], "difficulty": 7, "thinking": "Step 1: N-Queens asks for the count of valid placements on an NxN board.\n\nStep 2: Track queen positions in a list where queens[i] = column of queen in row i.\n\nStep 3: For conflict checking: same column means queens[i] == queens[j], diagonal means |i-j| == |queens[i]-queens[j]|.\n\nStep 4: Use recursive backtracking, placing one queen per row.\n\nStep 5: Return 1 when we've placed n queens (reached row n), sum all valid continuations.", "solution_code": "def n_queens(n: int) -> int:\n    def can_place(queens, row, col):\n        for i in range(row):\n            if queens[i] == col or abs(queens[i] - col) == row - i:\n                return False\n        return True\n\n    count = 0\n    queens = [-1] * n\n\n    def place(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if can_place(queens, row, col):\n                queens[row] = col\n                place(row + 1)\n                queens[row] = -1\n\n    place(0)\n    return count", "raw_response": "<think>\nStep 1: N-Queens asks for the count of valid placements on an NxN board.\n\nStep 2: Track queen positions in a list where queens[i] = column of queen in row i.\n\nStep 3: For conflict checking: same column means queens[i] == queens[j], diagonal means |i-j| == |queens[i]-queens[j]|.\n\nStep 4: Use recursive backtracking, placing one queen per row.\n\nStep 5: Return 1 when we've placed n queens (reached row n), sum all valid continuations.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def can_place(queens, row, col):\n        for i in range(row):\n            if queens[i] == col or abs(queens[i] - col) == row - i:\n                return False\n        return True\n\n    count = 0\n    queens = [-1] * n\n\n    def place(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if can_place(queens, row, col):\n                queens[row] = col\n                place(row + 1)\n                queens[row] = -1\n\n    place(0)\n    return count\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_10", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [5], "expected_output": 10}, {"input_args": [4], "expected_output": 2}, {"input_args": [4], "expected_output": 2}, {"input_args": [5], "expected_output": 10}, {"input_args": [6], "expected_output": 4}], "difficulty": 7, "thinking": "Step 1: N-Queens asks for the count of valid placements on an NxN board.\n\nStep 2: Track queen positions in a list where queens[i] = column of queen in row i.\n\nStep 3: For conflict checking: same column means queens[i] == queens[j], diagonal means |i-j| == |queens[i]-queens[j]|.\n\nStep 4: Use recursive backtracking, placing one queen per row.\n\nStep 5: Return 1 when we've placed n queens (reached row n), sum all valid continuations.", "solution_code": "def n_queens(n: int) -> int:\n    def can_place(queens, row, col):\n        for i in range(row):\n            if queens[i] == col or abs(queens[i] - col) == row - i:\n                return False\n        return True\n\n    count = 0\n    queens = [-1] * n\n\n    def place(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if can_place(queens, row, col):\n                queens[row] = col\n                place(row + 1)\n                queens[row] = -1\n\n    place(0)\n    return count", "raw_response": "<think>\nStep 1: N-Queens asks for the count of valid placements on an NxN board.\n\nStep 2: Track queen positions in a list where queens[i] = column of queen in row i.\n\nStep 3: For conflict checking: same column means queens[i] == queens[j], diagonal means |i-j| == |queens[i]-queens[j]|.\n\nStep 4: Use recursive backtracking, placing one queen per row.\n\nStep 5: Return 1 when we've placed n queens (reached row n), sum all valid continuations.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def can_place(queens, row, col):\n        for i in range(row):\n            if queens[i] == col or abs(queens[i] - col) == row - i:\n                return False\n        return True\n\n    count = 0\n    queens = [-1] * n\n\n    def place(row):\n        nonlocal count\n        if row == n:\n            count += 1\n            return\n        for col in range(n):\n            if can_place(queens, row, col):\n                queens[row] = col\n                place(row + 1)\n                queens[row] = -1\n\n    place(0)\n    return count\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_11", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [1], "expected_output": 1}, {"input_args": [2], "expected_output": 0}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [3], "expected_output": 0}], "difficulty": 3, "thinking": "Step 1: N-Queens counting problem - find number of ways to place N queens safely.\n\nStep 2: Safe placement means no two queens in same row, column, or diagonal.\n\nStep 3: Process row by row. For each row, try all columns. Skip invalid positions.\n\nStep 4: Track used columns and diagonals. Diagonals identified by row-col (positive) and row+col (negative).\n\nStep 5: Increment counter when row equals n (all queens placed successfully).", "solution_code": "def n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        total = 0\n        for col in range(n):\n            if col not in cols and (row - col) not in d1 and (row + col) not in d2:\n                total += solve(row + 1, cols | {col}, d1 | {row - col}, d2 | {row + col})\n        return total\n\n    return solve(0, set(), set(), set())", "raw_response": "<think>\nStep 1: N-Queens counting problem - find number of ways to place N queens safely.\n\nStep 2: Safe placement means no two queens in same row, column, or diagonal.\n\nStep 3: Process row by row. For each row, try all columns. Skip invalid positions.\n\nStep 4: Track used columns and diagonals. Diagonals identified by row-col (positive) and row+col (negative).\n\nStep 5: Increment counter when row equals n (all queens placed successfully).\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        total = 0\n        for col in range(n):\n            if col not in cols and (row - col) not in d1 and (row + col) not in d2:\n                total += solve(row + 1, cols | {col}, d1 | {row - col}, d2 | {row + col})\n        return total\n\n    return solve(0, set(), set(), set())\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_12", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [4], "expected_output": 2}, {"input_args": [3], "expected_output": 0}, {"input_args": [2], "expected_output": 0}, {"input_args": [3], "expected_output": 0}, {"input_args": [3], "expected_output": 0}], "difficulty": 3, "thinking": "Step 1: N-Queens counting problem - find number of ways to place N queens safely.\n\nStep 2: Safe placement means no two queens in same row, column, or diagonal.\n\nStep 3: Process row by row. For each row, try all columns. Skip invalid positions.\n\nStep 4: Track used columns and diagonals. Diagonals identified by row-col (positive) and row+col (negative).\n\nStep 5: Increment counter when row equals n (all queens placed successfully).", "solution_code": "def n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        total = 0\n        for col in range(n):\n            if col not in cols and (row - col) not in d1 and (row + col) not in d2:\n                total += solve(row + 1, cols | {col}, d1 | {row - col}, d2 | {row + col})\n        return total\n\n    return solve(0, set(), set(), set())", "raw_response": "<think>\nStep 1: N-Queens counting problem - find number of ways to place N queens safely.\n\nStep 2: Safe placement means no two queens in same row, column, or diagonal.\n\nStep 3: Process row by row. For each row, try all columns. Skip invalid positions.\n\nStep 4: Track used columns and diagonals. Diagonals identified by row-col (positive) and row+col (negative).\n\nStep 5: Increment counter when row equals n (all queens placed successfully).\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    def solve(row, cols, d1, d2):\n        if row == n:\n            return 1\n        total = 0\n        for col in range(n):\n            if col not in cols and (row - col) not in d1 and (row + col) not in d2:\n                total += solve(row + 1, cols | {col}, d1 | {row - col}, d2 | {row + col})\n        return total\n\n    return solve(0, set(), set(), set())\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_13", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [4], "expected_output": 2}, {"input_args": [5], "expected_output": 10}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [4], "expected_output": 2}], "difficulty": 4, "thinking": "Step 1: N-Queens problem requires counting non-attacking queen arrangements on NxN board.\n\nStep 2: Queens attack horizontally, vertically, and diagonally. Place one queen per row.\n\nStep 3: For each position (row, col), check: column not used, main diagonal (row-col) not used, anti-diagonal (row+col) not used.\n\nStep 4: Use backtracking: try each column, mark as used, recurse, then unmark.\n\nStep 5: Base case returns 1 (found valid solution), sum all possibilities.", "solution_code": "def n_queens(n: int) -> int:\n    used_cols = set()\n    used_main_diag = set()\n    used_anti_diag = set()\n\n    def count_solutions(row):\n        if row == n:\n            return 1\n        solutions = 0\n        for col in range(n):\n            main_diag = row - col\n            anti_diag = row + col\n            if col in used_cols or main_diag in used_main_diag or anti_diag in used_anti_diag:\n                continue\n            used_cols.add(col)\n            used_main_diag.add(main_diag)\n            used_anti_diag.add(anti_diag)\n            solutions += count_solutions(row + 1)\n            used_cols.remove(col)\n            used_main_diag.remove(main_diag)\n            used_anti_diag.remove(anti_diag)\n        return solutions\n\n    return count_solutions(0)", "raw_response": "<think>\nStep 1: N-Queens problem requires counting non-attacking queen arrangements on NxN board.\n\nStep 2: Queens attack horizontally, vertically, and diagonally. Place one queen per row.\n\nStep 3: For each position (row, col), check: column not used, main diagonal (row-col) not used, anti-diagonal (row+col) not used.\n\nStep 4: Use backtracking: try each column, mark as used, recurse, then unmark.\n\nStep 5: Base case returns 1 (found valid solution), sum all possibilities.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    used_cols = set()\n    used_main_diag = set()\n    used_anti_diag = set()\n\n    def count_solutions(row):\n        if row == n:\n            return 1\n        solutions = 0\n        for col in range(n):\n            main_diag = row - col\n            anti_diag = row + col\n            if col in used_cols or main_diag in used_main_diag or anti_diag in used_anti_diag:\n                continue\n            used_cols.add(col)\n            used_main_diag.add(main_diag)\n            used_anti_diag.add(anti_diag)\n            solutions += count_solutions(row + 1)\n            used_cols.remove(col)\n            used_main_diag.remove(main_diag)\n            used_anti_diag.remove(anti_diag)\n        return solutions\n\n    return count_solutions(0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_14", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [4], "expected_output": 2}, {"input_args": [6], "expected_output": 4}, {"input_args": [6], "expected_output": 4}, {"input_args": [5], "expected_output": 10}, {"input_args": [4], "expected_output": 2}], "difficulty": 4, "thinking": "Step 1: N-Queens problem requires counting non-attacking queen arrangements on NxN board.\n\nStep 2: Queens attack horizontally, vertically, and diagonally. Place one queen per row.\n\nStep 3: For each position (row, col), check: column not used, main diagonal (row-col) not used, anti-diagonal (row+col) not used.\n\nStep 4: Use backtracking: try each column, mark as used, recurse, then unmark.\n\nStep 5: Base case returns 1 (found valid solution), sum all possibilities.", "solution_code": "def n_queens(n: int) -> int:\n    used_cols = set()\n    used_main_diag = set()\n    used_anti_diag = set()\n\n    def count_solutions(row):\n        if row == n:\n            return 1\n        solutions = 0\n        for col in range(n):\n            main_diag = row - col\n            anti_diag = row + col\n            if col in used_cols or main_diag in used_main_diag or anti_diag in used_anti_diag:\n                continue\n            used_cols.add(col)\n            used_main_diag.add(main_diag)\n            used_anti_diag.add(anti_diag)\n            solutions += count_solutions(row + 1)\n            used_cols.remove(col)\n            used_main_diag.remove(main_diag)\n            used_anti_diag.remove(anti_diag)\n        return solutions\n\n    return count_solutions(0)", "raw_response": "<think>\nStep 1: N-Queens problem requires counting non-attacking queen arrangements on NxN board.\n\nStep 2: Queens attack horizontally, vertically, and diagonally. Place one queen per row.\n\nStep 3: For each position (row, col), check: column not used, main diagonal (row-col) not used, anti-diagonal (row+col) not used.\n\nStep 4: Use backtracking: try each column, mark as used, recurse, then unmark.\n\nStep 5: Base case returns 1 (found valid solution), sum all possibilities.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    used_cols = set()\n    used_main_diag = set()\n    used_anti_diag = set()\n\n    def count_solutions(row):\n        if row == n:\n            return 1\n        solutions = 0\n        for col in range(n):\n            main_diag = row - col\n            anti_diag = row + col\n            if col in used_cols or main_diag in used_main_diag or anti_diag in used_anti_diag:\n                continue\n            used_cols.add(col)\n            used_main_diag.add(main_diag)\n            used_anti_diag.add(anti_diag)\n            solutions += count_solutions(row + 1)\n            used_cols.remove(col)\n            used_main_diag.remove(main_diag)\n            used_anti_diag.remove(anti_diag)\n        return solutions\n\n    return count_solutions(0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_15", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [5], "expected_output": 10}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [1], "expected_output": 1}, {"input_args": [5], "expected_output": 10}], "difficulty": 5, "thinking": "Step 1: Count valid N-Queens configurations where no queens attack each other.\n\nStep 2: Key observation - place exactly one queen per row, track column and diagonal conflicts.\n\nStep 3: For NxN board, there are n columns, 2n-1 main diagonals, 2n-1 anti-diagonals.\n\nStep 4: Main diagonal index: col - row + n - 1 (shifted to be non-negative)\nAnti-diagonal index: col + row\n\nStep 5: Recursively try each column, backtrack on conflicts, count successful placements.", "solution_code": "def n_queens(n: int) -> int:\n    col_mask = [False] * n\n    main_diag = [False] * (2 * n - 1)\n    anti_diag = [False] * (2 * n - 1)\n\n    def backtrack(row):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            md = col - row + n - 1\n            ad = col + row\n            if col_mask[col] or main_diag[md] or anti_diag[ad]:\n                continue\n            col_mask[col] = main_diag[md] = anti_diag[ad] = True\n            count += backtrack(row + 1)\n            col_mask[col] = main_diag[md] = anti_diag[ad] = False\n        return count\n\n    return backtrack(0)", "raw_response": "<think>\nStep 1: Count valid N-Queens configurations where no queens attack each other.\n\nStep 2: Key observation - place exactly one queen per row, track column and diagonal conflicts.\n\nStep 3: For NxN board, there are n columns, 2n-1 main diagonals, 2n-1 anti-diagonals.\n\nStep 4: Main diagonal index: col - row + n - 1 (shifted to be non-negative)\nAnti-diagonal index: col + row\n\nStep 5: Recursively try each column, backtrack on conflicts, count successful placements.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    col_mask = [False] * n\n    main_diag = [False] * (2 * n - 1)\n    anti_diag = [False] * (2 * n - 1)\n\n    def backtrack(row):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            md = col - row + n - 1\n            ad = col + row\n            if col_mask[col] or main_diag[md] or anti_diag[ad]:\n                continue\n            col_mask[col] = main_diag[md] = anti_diag[ad] = True\n            count += backtrack(row + 1)\n            col_mask[col] = main_diag[md] = anti_diag[ad] = False\n        return count\n\n    return backtrack(0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
{"problem_type": "n_queens", "problem_id": "n_queens_16", "problem_title": "N-Queens Count", "problem_description": "Count the number of solutions to the N-Queens puzzle.\n\nThe N-Queens puzzle is placing N chess queens on an N\u00d7N chessboard such\nthat no two queens attack each other.\n\nQueens can attack horizontally, vertically, and diagonally.\n\nExamples:\n- n_queens(1) -> 1\n- n_queens(4) -> 2\n- n_queens(8) -> 92\n\nYour function must work for any positive integer n.", "function_signature": "def n_queens(n: int) -> int:", "function_name": "n_queens", "test_cases": [{"input_args": [6], "expected_output": 4}, {"input_args": [5], "expected_output": 10}, {"input_args": [1], "expected_output": 1}, {"input_args": [4], "expected_output": 2}, {"input_args": [5], "expected_output": 10}], "difficulty": 5, "thinking": "Step 1: Count valid N-Queens configurations where no queens attack each other.\n\nStep 2: Key observation - place exactly one queen per row, track column and diagonal conflicts.\n\nStep 3: For NxN board, there are n columns, 2n-1 main diagonals, 2n-1 anti-diagonals.\n\nStep 4: Main diagonal index: col - row + n - 1 (shifted to be non-negative)\nAnti-diagonal index: col + row\n\nStep 5: Recursively try each column, backtrack on conflicts, count successful placements.", "solution_code": "def n_queens(n: int) -> int:\n    col_mask = [False] * n\n    main_diag = [False] * (2 * n - 1)\n    anti_diag = [False] * (2 * n - 1)\n\n    def backtrack(row):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            md = col - row + n - 1\n            ad = col + row\n            if col_mask[col] or main_diag[md] or anti_diag[ad]:\n                continue\n            col_mask[col] = main_diag[md] = anti_diag[ad] = True\n            count += backtrack(row + 1)\n            col_mask[col] = main_diag[md] = anti_diag[ad] = False\n        return count\n\n    return backtrack(0)", "raw_response": "<think>\nStep 1: Count valid N-Queens configurations where no queens attack each other.\n\nStep 2: Key observation - place exactly one queen per row, track column and diagonal conflicts.\n\nStep 3: For NxN board, there are n columns, 2n-1 main diagonals, 2n-1 anti-diagonals.\n\nStep 4: Main diagonal index: col - row + n - 1 (shifted to be non-negative)\nAnti-diagonal index: col + row\n\nStep 5: Recursively try each column, backtrack on conflicts, count successful placements.\n</think>\n\n```python\ndef n_queens(n: int) -> int:\n    col_mask = [False] * n\n    main_diag = [False] * (2 * n - 1)\n    anti_diag = [False] * (2 * n - 1)\n\n    def backtrack(row):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(n):\n            md = col - row + n - 1\n            ad = col + row\n            if col_mask[col] or main_diag[md] or anti_diag[ad]:\n                continue\n            col_mask[col] = main_diag[md] = anti_diag[ad] = True\n            count += backtrack(row + 1)\n            col_mask[col] = main_diag[md] = anti_diag[ad] = False\n        return count\n\n    return backtrack(0)\n```", "teacher_model": "synthetic", "verified": true, "passed_tests": 5, "total_tests": 5, "timestamp": "2025-12-06T18:15:26.093709"}
